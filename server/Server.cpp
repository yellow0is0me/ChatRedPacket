// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../thrift/gen-cpp/ChatRedPacket.h"
#include "src/User.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include "sql/connection_pool.h"
#include "cppconn/connection.h"
#include "cppconn/resultset.h"
#include "src/RedPacket.h"
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/uuid/uuid_generators.hpp>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace crp;
using namespace std;

class ChatRedPacketHandler : virtual public ChatRedPacketIf {
public:
    map<string, string> uniqueIdList;
    map<string, string> receiveUserList;
    ConnPool *connpool;

    ChatRedPacketHandler() {
        // Your initialization goes here
        connpool = ConnPool::GetInstance();
    }

    //0.校验
    //1.占用金额
    //2.创建红包
    //3.拆分金额
    void createRedPacket(OperateResultDto &_return, const RedPacketCreateDto &createDto) {

        boost::uuids::uuid a_uuid = boost::uuids::random_generator()();
        string uuid_string = boost::uuids::to_string(a_uuid);

        Connection *con = nullptr;
        try {
            if (createDto.uniqueId.empty())
                throw logic_error("uniqueId is null");
            //uniqueId做sql注入的检查，算法的校验
            if (createDto.userId <= 0)
                throw logic_error("invalid userId");
            if (createDto.count <= 0)
                throw logic_error("invalid count");
            if (createDto.amount <= 0)
                throw logic_error("invalid amount");
            //唯一校验->uniqueId
            if (uniqueIdList.find(createDto.uniqueId) != uniqueIdList.end()) {
                throw logic_error("Duplicate request");
            } else {
                uniqueIdList.insert(make_pair(createDto.uniqueId, uuid_string));
            }

            //找到用户，校验用户是否存在，且账户金额大于红包金额
            con = connpool->GetConnection();
            User user = User::getUserById(createDto.userId, con);
            if (user.get_amount() < createDto.amount) {
                throw logic_error("User amount must >= red packet amount");
            }
            //创建红包
            RedPacket redPacket(createDto.userId, createDto.count, createDto.amount,
                                           createDto.uniqueId);
            //插入数据库
            int result = redPacket.createRedPacket(con);
            //拆分红包
            RedPacket::splitRedPacket(&redPacket);
            //插入数据库
            result = redPacket.createRedPacketLineList(con);
            //扣减账户余额，只要够就行
            result = user.subAmount(createDto.amount, con);

            //提交
            con->commit();

            _return.status = 1;
            connpool->ReleaseConnection(con);
            if (uniqueIdList.find(createDto.uniqueId) != uniqueIdList.end()
                && uniqueIdList.find(createDto.uniqueId)->second == uuid_string) {
                uniqueIdList.erase(createDto.uniqueId);
            }
        }
        catch (logic_error &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return.status = 0;
            _return.message = e.what();
            if (uniqueIdList.find(createDto.uniqueId) != uniqueIdList.end()
                && uniqueIdList.find(createDto.uniqueId)->second == uuid_string) {
                uniqueIdList.erase(createDto.uniqueId);
            }
        } catch (exception &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return.status = 0;
            _return.message = e.what();
            if (uniqueIdList.find(createDto.uniqueId) != uniqueIdList.end()
                && uniqueIdList.find(createDto.uniqueId)->second == uuid_string) {
                uniqueIdList.erase(createDto.uniqueId);
            }
        }
    }

    void receiveRedPacket(RedPacketReceiveResponseDto &_return, const RedPacketReceiveDto &receiveDto) {

        boost::uuids::uuid a_uuid = boost::uuids::random_generator()();
        string uuid_string = boost::uuids::to_string(a_uuid);
        std::string key = "";

        Connection *con = nullptr;
        try {
            if (receiveDto.userId <= 0)
                throw logic_error("invalid userId");
            if (receiveDto.redPacketId <= 0)
                throw logic_error("invalid redPacketId");
            key = to_string(receiveDto.redPacketId) + "_" + to_string(receiveDto.userId);

            //避免一个红包一个用户重复抢的问题
            if (receiveUserList.find(key) != receiveUserList.end()) {
                throw logic_error("Duplicate request");
            } else {
                receiveUserList.insert(make_pair(key, uuid_string));
            }

            con = connpool->GetConnection();
            //获取拆红包的user
            User user = User::getUserById(receiveDto.userId, con);
            //获取并锁定指定的红包
            //这里可以在创建的时候，把创建好的红包放到缓存里，抢红包的时候抢缓存里的，然后更新数据库
            auto redPacketLine = RedPacketLine::getAndUpdateRedPacketLine(receiveDto.redPacketId, receiveDto.userId,
                                                                          con);
            //增加账户余额
            //可异步处理
            int result = user.addAmount(redPacketLine.getReceiveAmount(), con);

            //提交
            con->commit();

            _return.status = 1;
            _return.receiveAmount = redPacketLine.getReceiveAmount();
            connpool->ReleaseConnection(con);

            if (receiveUserList.find(key) != receiveUserList.end()
                && receiveUserList.find(key)->second == uuid_string) {
                receiveUserList.erase(key);
            }
        }
        catch (logic_error &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return.status = 0;
            _return.message = e.what();
            if (receiveUserList.find(key) != receiveUserList.end()
                && receiveUserList.find(key)->second == uuid_string) {
                receiveUserList.erase(key);
            }
        } catch (exception &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return.status = 0;
            _return.message = e.what();
            if (receiveUserList.find(key) != receiveUserList.end()
                && receiveUserList.find(key)->second == uuid_string) {
                receiveUserList.erase(key);
            }
        }
    }

    void queryRedPacketStatus(std::vector<QueryResultRedPacketDto> &_return, const QueryByRedPacketIdDto &queryDto) {
        Connection *con = nullptr;
        try {
            if (queryDto.redPacketId <= 0)
                throw logic_error("invalid redPacketId");
            con = connpool->GetConnection();
            _return = RedPacketLine::queryRedPacketStatus(queryDto.redPacketId, con);
            con->commit();
            connpool->ReleaseConnection(con);
        } catch (exception &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return = vector<QueryResultRedPacketDto>();
        }
    }

    void queryReceiveRedPacketByUser(std::vector<QueryResultReceiveUserDto> &_return, const QueryByUserIdDto &queryDto) {
        Connection *con = nullptr;
        try {
            if (queryDto.userId <= 0)
                throw logic_error("invalid userId");
            con = connpool->GetConnection();
            _return = RedPacketLine::queryReceiveRedPacketByUser(queryDto.userId, con);
            con->commit();
            connpool->ReleaseConnection(con);
        } catch (exception &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return = vector<QueryResultReceiveUserDto>();
        }
    }

    void queryCreateRedPacketByUser(std::vector<QueryResultUserDto> &_return, const QueryByUserIdDto &queryDto) {
        Connection *con = nullptr;
        try {
            if (queryDto.userId <= 0)
                throw logic_error("invalid userId");
            con = connpool->GetConnection();
            _return = RedPacket::queryCreateRedPacketByUser(queryDto.userId, con);
            con->commit();
            connpool->ReleaseConnection(con);
        } catch (exception &e) {
            if (con != nullptr) {
                con->rollback();
                connpool->ReleaseConnection(con);
            }
            _return = vector<QueryResultUserDto>();
        }
    }
};

int main(int argc, char **argv) {
    int port = 9090;
    boost::shared_ptr<ChatRedPacketHandler> handler(new ChatRedPacketHandler());
    boost::shared_ptr<TProcessor> processor(new ChatRedPacketProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}

